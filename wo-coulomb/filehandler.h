#ifndef FILEHANDLER_H
#define FILEHANDLER_H

/**
 * @file filehandler.h
 * @author Konrad Merkel
 * @brief Routines to read and write files, e.g. COULOMB-files or xsf-files
 *
 */

#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <list>
#include <map>
#include <algorithm>
#include <filesystem>
#include <regex>

#include "coulombIntegral.h"
#include "wannierfunction.h"
#include "CHGCAR.h"
#include "density.h"
#include "opticalDipole.h"
#include "solver.h"

using namespace std;


/**
 * @brief Helper function to split strings.
 *
 * @param s
 * @param delimiter
 * @return vector<string>
 */
vector<string> split (string const& s, string const& delimiter) {
    size_t pos_start = 0, pos_end, delim_len = delimiter.length();
    string token;
    vector<string> res;

    while ((pos_end = s.find (delimiter, pos_start)) != string::npos) {
        token = s.substr (pos_start, pos_end - pos_start);
        pos_start = pos_end + delim_len;
        res.push_back (token);
    }

    res.push_back (s.substr (pos_start));
    return res;
}

vector<string> splitBySpacesAndTabs(const string& str) {
    vector<string> result;

    // Regular expression to match one or more spaces or tabs
    regex re("\\s+");  // "\\s+" matches one or more spaces or tabs

    // Use sregex_token_iterator to split the string
    sregex_token_iterator it(str.begin(), str.end(), re, -1);
    sregex_token_iterator end;

    // Copy the results to a vector
    for (; it != end; ++it) {
        if (*it != "") result.push_back(*it);
    }

    return result;
}

double stringToDouble(const string& str) {
    stringstream ss(str);
    double value;

    // Try to read a double from the stringstream
    ss >> value;

    // Check if the conversion was successful
    // Failures will result in the stringstream being in a fail state
    if (ss.fail() || !ss.eof()) {
        return -1;  // Conversion failed
    }

    return value;  // Return the successfully converted double
}



/**
 * @brief (Static) functionalities to read and write *.xsf files
 *
 */
class XSF_controller
{

public:

    /**
     * @brief Read WannierFunction from xsf-file (generated by wannier90)
     *
     * @param filename      path to xsf-file
     * @param id            Wannier-id according to wannier90 / electronic structure
     * @return WannierFunction
     */
    static WannierFunction read_file(const string& filename, int id=0, int rank=0)
    {
        // allocate memory for all small objects
        vector< vector<double> > unitcell;
        vector< vector<double> > CONVVEC;
        vector< vector<double> > vec_datagrid;
        unitcell.resize(3, vector<double>(3,0.0));
        CONVVEC.resize(3, vector<double>(3,0.0));
        vec_datagrid.resize(3, vector<double>(3,0.0));

        vector<int> dim(3);
        vector<double> origin(3);
        double* data = nullptr;


        // read and parse file
        if (rank==0) cout << "open WF from file: " << filename << endl;
        ifstream file(filename);
        if (file.is_open()) {
            string line;
            while (getline(file, line)) {
                if (line == "PRIMVEC"){
                    for (int i=0; i <3 ; i++) {
                        for (int j=0; j <3 ; j++) {
                            file >> unitcell[i][j];
                        }
                    }
                }

                if (line == "CONVVEC"){
                    for (int i=0; i <3 ; i++) {
                        for (int j=0; j <3 ; j++) {
                            file >> CONVVEC[i][j];
                        }
                    }
                }

                if (line == "BEGIN_DATAGRID_3D_UNKNOWN"){
                    for (int i=0; i <3 ; i++) {
                        file >> dim[i];
                    }

                    for (int i=0; i <3 ; i++) {
                        file >> origin[i];  // the origin is usually shifted by 1 data point. Why?
                    }

                    for (int i=0; i <3 ; i++) {
                        for (int j=0; j <3 ; j++) {
                            file >> vec_datagrid[i][j];
                        }
                    }

                    int Num_data_points = dim[0]*dim[1]*dim[2];
                    data = (double*) malloc(Num_data_points * sizeof(double));
                    for (int i=0; i<Num_data_points ; i++) {
                        // x index is fastest
                        // z index is slowest
                        file >> data[i];
                    }
                    break;
                }
            }
            file.close();

            // rescale lattice of data points such that we get a periodic grid from
            // the regular grid in the xsf file
            for (int i=0; i<3; i++) {
                for (int j=0; j<3; j++) {
                    vec_datagrid[i][j] = vec_datagrid[i][j] * dim[i] / (dim[i]-1);
                }
            }

            if (data == nullptr)
                throw runtime_error("Cannot read data.");

            // create objects
            shared_ptr<RealMeshgrid> meshgrid = make_shared<RealMeshgrid>(dim, vec_datagrid, origin);
            WannierFunction wannier(id, meshgrid, unique_ptr<double[], free_deleter>{data}, unitcell);

            vector<double> supercell = wannier.getLatticeInUnitcellBasis();
            cout << setprecision(5);
            if (rank==0) {
                cout << "File already contains a supercell (" << supercell[0] << " x ";
                cout << supercell[1] << " x " << supercell[2] << ")\n";
                cout << setprecision(12);
                //  cout << "Volume supercell: " << meshgrid->getVgrid() << " --> " << meshgrid->getVgrid()/pow(2*M_PI,3) << endl;
                cout << "Norm from file: " << wannier.getNorm() << endl;
            }

            return wannier;

        } else {
            throw runtime_error("Cannot read file!");
        }
    }

    /**
     * @brief Saves a data array as xsf-file
     *
     * @param filename      path to xsf-file
     * @param meshgrid      real space grid of the supercell to which the data belongs
     * @param newValue      data array for every grid point
     * @return true         success
     */
    static bool save_file(const string& filename, const RealMeshgrid* meshgrid, double const* newValue) {
        return XSF_controller::save_file(filename, meshgrid, newValue, meshgrid->getLattice());
    }

    /**
     * @brief Saves a WannierFunction as xsf-file
     *
     * @param filename      path to xsf-file
     * @param wann          Wannier funciton
     * @return true         success
     */
    static bool save_file(const string& filename, WannierFunction const& wann) {
        return XSF_controller::save_file(filename, wann.getMeshgrid(), wann.getValue(), wann.getUnitcell());
    }

    /**
     * @brief Saves a data array as xsf-file
     *
     * @param filename      path to xsf-file
     * @param meshgrid      real space grid of the supercell to which the data belongs
     * @param value         data array for every grid point
     * @param unitcell      primitive unit cell
     * @return true         success
     */
    static bool save_file(const string& filename, const RealMeshgrid* meshgrid, const double* value, const vector< vector<double> >& unitcell)
    {
        ofstream file(filename);
        if (!file.is_open()) {
            cerr << "Cannot open file!" << endl;
            return false;
        }
        file << fixed;
        file << setprecision(12);

        file << "  # Generated by KM" << endl;
        file << "CRYSTAL" << endl;
        file << "PRIMVEC" << endl;
        for (int i=0; i <3 ; i++) {
            for (int j=0; j <3 ; j++) {
                file << "   " << unitcell[i][j];
            }
            file << endl;
        }
        file << "CONVVEC" << endl;
        for (int i=0; i <3 ; i++) {
            for (int j=0; j <3 ; j++) {
                file << "   " << unitcell[i][j];
            }
            file << endl;
        }
        file << "BEGIN_BLOCK_DATAGRID_3D" << endl;
        file << "3D_field" << endl;
        file << "BEGIN_DATAGRID_3D_UNKNOWN" << endl;
        file << "    " << meshgrid->getDim()[0] << "    " << meshgrid->getDim()[1] << "    " << meshgrid->getDim()[2] << endl;
        file << "    " << meshgrid->getOrigin()[0] << "    " << meshgrid->getOrigin()[1] << "    " << meshgrid->getOrigin()[2] << endl;
        for (int i=0; i <3 ; i++) {
            for (int j=0; j <3 ; j++) {
                file << "   " << meshgrid->getLattice()[i][j] / meshgrid->getDim()[i] * (meshgrid->getDim()[i]-1);
            }
            file << endl;
        }

        int N = meshgrid->getNumDataPoints();
        for (int i=0; i <N ; i++){
            file << "  " << value[i];
            if ((i+1)%6==0) {file << endl;}
        }
        file << "\nEND_DATAGRID_3D" << endl;
        file << "END_BLOCK_DATAGRID_3D" << endl;
        file.close();
        return true;
    }

    /**
     * @brief Saves a complex data array as xsf-file
     *
     * The xsf-file stores either real or imaginary part specified by the parameter 'index'
     *
     * @param filename      path to xsf-file
     * @param meshgrid      real space grid of the supercell to which the data belongs
     * @param value         data array for every grid point
     * @param unitcell      primitive unit cell
     * @param index         0=real part; 1=imaginary part
     * @return true
     * @return false
     */
    static bool save_file(const string& filename, const RealMeshgrid* meshgrid, const fftw_complex* value, const vector< vector<double> >& unitcell, int index=0)
    {
        double* dvalues = (double*) malloc(sizeof(double)*meshgrid->getNumDataPoints());
        for (int i=0; i<meshgrid->getNumDataPoints(); i++) {
            dvalues[i] = value[i][index];
        }
        return save_file(filename,meshgrid,dvalues,unitcell);
    }
};


CHGCAR read_CHGCAR(const string& filename, int rank=0) {

    // allocate memory for all small objects
    vector< vector<double> > unitcell;
    unitcell.resize(3, vector<double>(3,0.0));

    vector<int> dim(3);
    vector<double> origin{0,0,0};
    double scaling;


    // read and parse file
    if (rank==0) cout << "open CHGCAR from file: " << filename << endl;
    ifstream file(filename);
    if (file.is_open()) {
        string line;

        getline(file, line); // first line is a comment (skiped)
        file >> scaling;

        // read unit cell and apply scaling factor
        for (int i=0; i <3 ; i++) {
            for (int j=0; j <3 ; j++) {
                file >> unitcell[i][j];
                unitcell[i][j] *= scaling;
            }
        }

        // skip atoms
        getline(file, line);
        getline(file, line);
        getline(file, line);

        vector<string> num_atoms = splitBySpacesAndTabs(line);
        int Natoms=0;
        for (const string& n: num_atoms) {
            Natoms += stoi(n);
        }


        for (int i=0; i<Natoms; i++)
            getline(file, line);

        // empty line
        getline(file, line);
        file >> dim[0];
        file >> dim[1];
        file >> dim[2];
        getline(file, line);

        // create meshgrid
        shared_ptr<RealMeshgrid> mesh = make_shared<RealMeshgrid>(dim, unitcell, origin);

        int Num_data_points = mesh->getNumDataPoints();
        double V = mesh->getVgrid();
        unique_ptr<double[],free_deleter> data{ (double*) malloc(Num_data_points * sizeof(double)) };
        for (int i=0; i<Num_data_points ; i++) {
            // x index is fastest
            // z index is slowest
            file >> data[i];
            data[i] = data[i] / V;  // data needs to be rescaled to be aproper density
        }
        file.close();

        return CHGCAR(mesh, std::move(data));

    } else {
        throw runtime_error("Cannot read file!");
    }
}


class CoulombFileReader
{
protected:
    const string filename;
    double WW;
    double max_dist;
    vector<Integral> elements;
    bool success;

public:
    explicit CoulombFileReader(const string& filename_) : filename(filename_), WW(0), max_dist(-1), elements(0), success(false)
    {
        ifstream file(filename);
        if (!file.is_open()) {
            cerr << "Cannot open file: " << filename << endl;
            success = false;
            return;
        }

        string line;
        getline(file, line);
        vector<string> meta = splitBySpacesAndTabs(line); //split(line, delimiter);
        if (meta.size() < 3) {
            cerr << "Problems parsing first line of file: " << filename << " Expected 3 values." << endl;
            success = false;
            return;
        }
        int Num = stoi(meta[0]); // get number of matrix elements in plan file
        max_dist = stringToDouble(meta[1]);
        WW = stringToDouble(meta[2]);

        elements.resize(Num);

        // TODO change data structure of elements to list and allow a dynamical read in
        // Goal should be to get rid of the first line (number of elements)
        int i=0;
        while (file.peek() != EOF) {
            getline(file, line);

            if (line[0]=='#') continue;  // skip comments

            if (i>=Num) throw runtime_error("More elements in plan file than expected. Please check the first line of the file!");
            vector<string> v = splitBySpacesAndTabs(line); //split(line, delimiter);
            if (v.size() < 13) {
                cerr << "Cannot separate entries in Coulomb file.\n";
                throw runtime_error("Not possible to read file of type Coulomb-file.");
            } else {
                for (size_t j=0; j<13; j++) {
                    elements[i].indexes[j] = stoi(v[j]);
                    elements[i].setNormal();
                }
            }
            if(v.size() >= 14) {
                elements[i].value = stod(v[13]);
            }else{
                elements[i].value = NAN;
            }
            i++;
        }
        if (i!=Num) throw runtime_error("Different number of elements in Coulomb file than expected. Please check the first line of the file!");

        file.close();
        success = true;
    }
    ~CoulombFileReader() {}

    vector<Integral>& getElements() {return elements;}
    double getWW() const {return WW;}
    double getDist() const {return max_dist;}
    bool wasSuccessful() const {return success;}
};






/**
 * @brief (Static) functionalities to write output files
 *
 * These are COULOMB, LFE and TRANSITION files.
 *
 */
class OutputService
{
public:
    OutputService();
    ~OutputService();

    /**
     * @brief Writes the results (stored in vector of CoulombIntegral) to a COULOMB/LFE file
     *
     * The COULOMB file has the same format as a plan file. That means COULOMB files can also be
     * used as input files for later runs, e.g. for comparison of different implementations.
     * The COULOMB/LFE file is also the input for calculations of optical properties with WannierOptics.
     *
     * @param filename  path to output file (COULOMB or LFE file)
     * @param elements  computed Coulomb integrals
     * @return true     success
     */
    static bool writeResults(const string& filename, const list<Integral>& elements, const string& comment="", double max_dist = -1, double WW = 1)
    {
        ofstream file(filename);
        if (!file.is_open()) {
            cout << "Cannot open file!" << endl;
            return false;
        }

        file << fixed;
        file << setprecision(12);

        if (max_dist<0)
            file << elements.size() << "\t" <<  "<max_dist>\t" << WW << endl;
        else
            file << elements.size() << "\t" <<  max_dist << "\t" << WW << endl;
        file << "# Coulomb Matrix Elements in units of eV" << endl;
        file << "# " << comment << endl;
        file << "#c1\tc2\tv1\tv2\tRD (dummy for LFE)\tRc (S1 for LFE)\tRv (S2 for LFE)\tReal(W)\t\tImag(W)" << endl;


        for (const Integral& e: elements){
            file << e.toString() << "\t" << 0.0 << endl;
        }

        file.close();
        return true;
    }


    /**
     * @brief Write optical transiton elements (stored in OpticalDipolVector) to a TRANSITION file
     *
     * @param filename  path to output file (TRANSITON file)
     * @param elements  computed optical transition elements
     * @return true     success
     */
    static bool writeResults(const string& filename, const list<OpticalDipole>& elements)
    {
        ofstream file(filename);
        if (!file.is_open()) {
            cout << "Cannot open file!" << endl;
            return false;
        }

        file << fixed;
        file << setprecision(12);

        file << elements.size() << endl;
        file << "# Optical Transition Dipoles" << endl;
        file << "#c\tv\tshift vector\t\tdipole (x,y,z)" << endl;

        for (const auto& e : elements)
        {
            file << e.toString() << endl;
        }

        file.close();
        return true;
    }
};


/**
 * @brief Reads and parses general mapping files.
 *
 * @param mapping       map where results are stored
 * @param filename      path to mapping file
 * @param delimiter     delimiter in mapping file
 * @return true         success
 * @return false
 */
bool readMapping(map< int,string >& mapping, const string& filename, const string& delimiter = "-->", int rank=0) {
    ifstream file(filename);
    if (!file.is_open()) {
        if (rank==0) cerr << "Cannot open mapping file!" << endl;
        return false;
    }

    for(string line; getline( file, line ); )
    {
        if (line.size() == 0) continue;  // skip blank lines
        if (line[0] == '#') continue;    // skip comments

        vector<string> v = split(line, delimiter);

        if (v.size() != 2) {
            if (rank==0) cerr << "Error while parsing file\n";
            return false;
        }

        if (stoi(v[0])<0) {  // negative indexes would lead to error later on, because they would be interpreted as NO-intergals!!!
            throw runtime_error("Index of Wannier function cannot be negative!");
        }

        // remove white spaces
        string::iterator end_pos = remove(v[1].begin(), v[1].end(), ' ');
        v[1].erase(end_pos, v[1].end());

        if(mapping.insert({ stoi(v[0]), v[1] }).second == false) {
            throw runtime_error("Mapping seems inconsistent. Please check if the ids are unique!");
        }
    }

    file.close();
    return true;
}


/**
 * @brief Reads and parses plan files.
 *
 * @return true     success
 * @return false    reading not possible
 */
bool readPlan(vector<Integral>& elements, const string& planFile) {
    ifstream file(planFile);
    if (!file.is_open()) {
        cerr << "Cannot open plan file!" << endl;
        return false;
    }

    string line;
    getline(file, line);
    vector<string> meta = splitBySpacesAndTabs(line); //split(line, delimiter);
    if (meta.size() < 1) {
        cerr << "Problems parsing first line of file: " << planFile << " Expected 1 value." << endl;
        return false;
    }
    int Num = stoi(meta[0]); // get number of matrix elements in plan file

    elements.resize(Num);

    // TODO change data structure of elements to list and allow a dynamical read in
    // Goal should be to get rid of the first line (number of elements)

    int i=0;
    bool lineExtendFlag = false;
    while (file.peek() != EOF) {
        getline(file, line);

        if (line[0]=='#') continue;  // skip comments

        if (i>=Num) throw runtime_error("More elements in plan file than expected. Please check the first line of the file!");
        vector<string> v = splitBySpacesAndTabs(line);//split (line, delimiter);
        if (v.size() < 13) {
            cerr << "Cannot separate entries in custom integral file.\n";
            throw runtime_error("Not possible to read custom integral file.");
        }else if(v.size() > 13) {
            lineExtendFlag = true;
        }
        for (size_t j=0; j<13; j++) {
            elements[i].indexes[j] = stoi(v[j]);
        }
        elements[i].currentStatus = IntegralStatus::normal;  // TODO: find a better way
        elements[i].error_msg = "";
        i++;
    }
    if (lineExtendFlag) cout << "Found more than 13 columns in plan file! Only the first 13 columns will be used. All other are ignored.\n";

    if (i!=Num) throw runtime_error("Different number of elements in plan file than expected. Please check the first line of the file!");


    file.close();
    return true;
}

/**
 * @brief Checks if mapping and plan are compatible
 */
bool checkPlan(const vector<Integral>& elements, const map< int,string >& vMapping, const map< int,string >& cMapping) {

    if (elements.size() == 0)
        throw runtime_error("Plan is empty! Did you read the correct file?");

    if (cMapping.size() == 0)
        throw runtime_error("Mapping is empty! Did you read the correct file?");

    if (vMapping.size() == 0)
        throw runtime_error("Mapping is empty! Did you read the correct file?");

    for (size_t i=0; i<elements.size(); i++) {
        for (size_t j=0; j<2; j++) {
            if (cMapping.find(elements[i].indexes[j]) == cMapping.end()) {
                cerr << "Cannot map conduction wannier function with id = " << elements[i].indexes[j] << endl;
                return false;
            }
            if (vMapping.find(elements[i].indexes[j+2]) == vMapping.end()) {
                cerr << "Cannot map valence wannier function with id = " << elements[i].indexes[j+2] << endl;
                return false;
            }
        }
    }
    return true;
}


/**
 * @brief Prints the plan on screen.
 *
 * @param all if true the entire plan is printed, if false only the head is printed
 */
void printPlan(const vector<Integral>& elements, bool all=false) {
    cout << "Number of integrals: " << elements.size() << endl;
    cout << "# c1, c2, v1, v2, RD, Rc, Rv\n";
    size_t N=0;
    if (all) N=elements.size();
    else N=min(int(elements.size()), 10);
    for (size_t i=0; i<N; i++) {
        elements[i].print();
    }
    if (N<elements.size()) cout << "  ...  \n\n";
}

/**
 * @brief Read all Wannier functions from file.
 *
 * Wannier functions are than stored as WannierFunctions objects inside the vWannMap and
 * cWannMap. Only Wannier functions that are needed for the plan / CoulombIntegral vector are read from file.
 * This saves resources and time because Wannier functions that are not needed will not be used.
 *
 * @param supercellDim Dimensions of the supercell (in units of the supercell of the xsf-file!) if padding should be used
 */
map< int,WannierFunction > openAllWannierFunctions(const map< int,string >& mapping, const vector<int>& supercellDim = vector<int>{1,1,1}, int rank=0) {

    map< int,WannierFunction > WannMap{};

    for (auto itr = mapping.begin(); itr != mapping.end(); ++itr) {

        WannierFunction wann = XSF_controller::read_file(itr->second, itr->first, rank);
        createLargerSupercell(wann, supercellDim);
        WannMap.insert({ itr->first , std::move(wann) });
    }

    return WannMap;
}


bool saveIndicator_estimates(string const& filename, map<Density_descr,Density_indicator> const& indicators, const double extend_criterion) {  //TODO add ABSCHARGE_THRESHOLD


    ofstream file(filename);
    if (!file.is_open()) {
        cout << "Cannot open file!" << endl;
        return false;
    }

    // file << fixed;
    // file << setprecision(12);

    file << indicators.size() << "  " << extend_criterion << endl;
    file << "# Indicator - Parameter" << endl;
    file << "# v1 v2 iRx iRy iRz x y z charge extend" << endl;

    for (auto itr = indicators.begin(); itr != indicators.end(); ++itr) {
            file << itr->first.toString() << "\t";
            vector<double> indicator_data = itr->second.toVector();
            for (size_t i=0; i<indicator_data.size(); i++) {
                file << indicator_data[i] << "\t";
            }
            file << endl;
        }

    file.close();
    return true;
}


map<Density_descr,Density_indicator> readIndicator_estimates(string const& filename, double extend_criterion = -1) {  // TODO: check for errors in the file

    int rank, num_worker;
    MPI_Comm_rank(MPI_COMM_WORLD, &rank);
    MPI_Comm_size(MPI_COMM_WORLD, &num_worker);
    int N;
    double extend_crit;
    map<Density_descr,Density_indicator> indicators{};

    if (rank==0) cout << "Try to read indicator parameters from file " << filename << endl;


    if (!filesystem::exists(filename)) {
        if (rank==0) cout << "File does not exist " << filename << endl;
        return indicators;
    }


    ifstream file(filename);
    if (!file.is_open()) {
        if (rank==0) cerr << "Cannot open file " << filename << endl;
        return indicators;
    }

    // read file
    file >> N;
    file >> extend_crit;

    if (abs(extend_criterion - extend_crit) > 1e-8) {
        if (rank==0) cerr << "Extend criterion is not the same as in the file. Skip reading file\n";
        file.close();
        return indicators;
    }

    string line;
    int v1,v2,Rx,Ry,Rz;

    getline(file, line);
    getline(file, line);

    while (getline(file, line)) {

        file >> v1;
        file >> v2;
        file >> Rx;
        file >> Ry;
        file >> Rz;

        Density_descr ids = Density_descr(v1,v2, vector<int>{Rx,Ry,Rz});
        Density_indicator data;

        file >> data.x;
        file >> data.y;
        file >> data.z;
        file >> data.absCharge;
        file >> data.extend;

        indicators.insert({ids, data});
    }
    file.close();

    if (rank==0) cout << "data size :" << indicators.size() << endl;

    return indicators;
}



#endif // FILEHANDLER_H