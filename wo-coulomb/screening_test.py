#!/usr/bin/env python

import os
from functools import cached_property
import numpy as np
from copy import deepcopy

class CHGCAR:
    def __init__(self, filename) -> None:

        with open(filename) as file:
            lines = file.readlines()
            lines = [line.rstrip() for line in lines]

        # unit cell
        scaling = float(lines[1])
        self.unitcell = np.zeros((3,3))
        self.unitcell[0,:] = lines[2].split()
        self.unitcell[1,:] = lines[3].split()
        self.unitcell[2,:] = lines[4].split()
        self.unitcell = self.unitcell*scaling

        self.atom_species = lines[5].split()
        self.atom_species_count = np.array(lines[6].split(), dtype=np.int32)
        assert(len(self.atom_species) == len(self.atom_species_count))

        self.Natoms = np.sum(self.atom_species_count)
        self.atoms = []
        for s,c in zip(self.atom_species,self.atom_species_count):
            self.atoms.extend([s]*c)

        self.position_mode = lines[7]
        self.positions = np.zeros((self.Natoms, 3))

        for i in np.arange(self.Natoms):
            self.positions[i,:] = lines[8+i].split()

        line_index = self.Natoms + 9
        self.meshgrid = np.array(lines[line_index].split(), dtype=np.int32)
        line_index += 1

        N = self.meshgrid[0]*self.meshgrid[1]*self.meshgrid[2]
        self.data = np.zeros(N)

        self.origin_datagrid = np.zeros(3) # TODO: maybe better?
        self.vec_datagrid = deepcopy(self.unitcell)

        data_index = 0
        for line in lines[line_index:]:
            tmp = line.split()
            self.data[data_index:data_index+len(tmp)] = tmp
            data_index += len(tmp)
            if data_index >= N:
                break

        # reshape data as 3D array
        self.data = np.reshape(self.data, self.meshgrid, order="F")

    def coarseGrain(self, factor=2):
        # self.data = (self.data[::factor, ::factor, ::factor] + self.data[1::factor, 1::factor, 1::factor])/2.
        self.data = self.data[::factor, ::factor, ::factor]

        self.meshgrid = self.data.shape

    def repeatSupercell(self, nx,ny,nz):
        newMesh = self.meshgrid * np.array([nx,ny,nz])
        newData = np.zeros(newMesh)

        for x in np.arange(nx):
            for y in np.arange(ny):
                for z in np.arange(nz):
                    newData[x*self.meshgrid[0] : (x+1)*self.meshgrid[0], y*self.meshgrid[1] : (y+1)*self.meshgrid[1], z*self.meshgrid[2] : (z+1)*self.meshgrid[2]] = self.data[:,:,:]

        self.data = newData
        self.meshgrid = newMesh
        self.vec_datagrid[:,0] *= nx  # TODO check
        self.vec_datagrid[:,1] *= ny
        self.vec_datagrid[:,2] *= nz

    def save_xsf(self, filename):
        with open(filename, 'w') as file:
            file.write('# generated by KM\n')
            file.write('CRYSTAL\n')
            file.write('PRIMVEC\n')
            file.write(f'    {self.unitcell[0,0]:.7f}  {self.unitcell[0,1]:.7f}  {self.unitcell[0,2]:.7f}\n')
            file.write(f'    {self.unitcell[1,0]:.7f}  {self.unitcell[1,1]:.7f}  {self.unitcell[1,2]:.7f}\n')
            file.write(f'    {self.unitcell[2,0]:.7f}  {self.unitcell[2,1]:.7f}  {self.unitcell[2,2]:.7f}\n')
            file.write('CONVVEC\n')
            file.write(f'    {self.unitcell[0,0]:.7f}  {self.unitcell[0,1]:.7f}  {self.unitcell[0,2]:.7f}\n')
            file.write(f'    {self.unitcell[1,0]:.7f}  {self.unitcell[1,1]:.7f}  {self.unitcell[1,2]:.7f}\n')
            file.write(f'    {self.unitcell[2,0]:.7f}  {self.unitcell[2,1]:.7f}  {self.unitcell[2,2]:.7f}\n')
            file.write('PRIMCOORD\n')
            file.write(f'    {self.Natoms}  1\n')
            for i in np.arange(self.Natoms):

                if self.position_mode[0]=='D':
                    pos = self.positions @ self.unitcell.T
                else:
                    pos = self.positions

                file.write(f'{self.atoms[i]}  {pos[i][0]:.7f}  {pos[i][1]:.7f}  {pos[i][2]:.7f}\n')
            file.write('\n\n')

            file.write('BEGIN_BLOCK_DATAGRID_3D\n')
            file.write('3D_field\n')
            file.write('BEGIN_DATAGRID_3D_UNKNOWN\n')
            mesh_xsf = np.array([self.meshgrid[0], self.meshgrid[1], self.meshgrid[2] ])
            file.write('  '.join(str(e) for e in mesh_xsf))
            file.write('\n')
            file.write(f'   {self.origin_datagrid[0]:.7f}  {self.origin_datagrid[1]:.7f}  {self.origin_datagrid[2]:.7f}\n')
            for i in np.arange(3):
                datagrid = self.vec_datagrid[i,:] * (self.meshgrid[i]-1) / self.meshgrid[i]
                for j in np.arange(3):
                    file.write(f'   {datagrid[j]:.7f}')
                file.write('\n')


            # data = np.zeros(mesh_xsf)
            # data[:-1,:-1,:-1] = self.data
            data = self.data

            data_f = data.flatten(order="F")

            i = 1
            for num in data_f:
                file.write(f' {num:.8f}')
                if i%6 == 0:
                    file.write('\n')
                    i = 1
                else:
                    i += 1

            file.write('\nEND_DATAGRID_3D\n')
            file.write('END_BLOCK_DATAGRID_3D\n')

    def Vunitcell(self):
        return np.dot(np.cross(self.unitcell[0], self.unitcell[1]), self.unitcell[2])

    def Vgrid(self):
        return np.dot(np.cross(self.vec_datagrid[0], self.vec_datagrid[1]), self.vec_datagrid[2])


    def NELECT(self):
        return np.sum(self.data / (self.meshgrid[0]*self.meshgrid[1]*self.meshgrid[2]))

    def dV(self):
        return self.Vgrid()/(self.meshgrid[0]*self.meshgrid[1]*self.meshgrid[2])

    def number_density(self):
        # because of pseudo potentials charge densities can be negative
        # we need to renormalize for this reason

        #density = np.absolute(self.data) / (self.NELECT* self.Vcell)
        density = self.data / (self.NELECT* self.Vgrid)
        density[density<=0] = 1e-8
        N = np.sum(density * self.dV)
        return density / N


class wfn_obj:
    def __init__(self, filename) -> None:

        self.unitcell = np.zeros((3,3))
        self.convvec = np.zeros((3,3))

        with open(filename) as file:
            lines = file.readlines()
            lines = [line.rstrip() for line in lines]

        # search for keyword crystal
        i = 0
        while i < len(lines):
            if "PRIMVEC" == lines[i]:
                break
            i += 1

        # unit cell
        self.unitcell[0,:] = lines[i+1].split()
        self.unitcell[1,:] = lines[i+2].split()
        self.unitcell[2,:] = lines[i+3].split()
        i += 3

        while i < len(lines):
            if "CONVVEC" == lines[i]:
                break
            i += 1

        # convetional lattice vectors
        self.convvec[0,:] = lines[i+1].split()
        self.convvec[1,:] = lines[i+2].split()
        self.convvec[2,:] = lines[i+3].split()
        i += 3

        while i < len(lines):
            if "PRIMCOORD" == lines[i]:
                break
            i += 1

        self.atoms_per_unitcell = np.int64(lines[i+1].split()[0])
        self.atom_species = []
        self.positions = np.zeros((self.atoms_per_unitcell, 3))
        i += 2

        for j in np.arange(self.atoms_per_unitcell):
            data = lines[i+j].split()
            self.atom_species.append(data[0])
            self.positions[j,:] = np.array([data[1], data[2], data[3]])
        i += self.atoms_per_unitcell

        while i < len(lines):
            if "BEGIN_DATAGRID_3D_UNKNOWN" == lines[i]:
                break
            i += 1

        self.meshgrid = np.array(lines[i+1].split(), dtype=np.int32)
        self.origin_datagrid = np.array(lines[i+2].split(), dtype=np.float128)
        self.vec_datagrid = np.zeros((3,3))
        for j in np.arange(3):
            self.vec_datagrid[:,j] = np.array(lines[i+3+j].split(), dtype=np.float128) *self.meshgrid[j] / (self.meshgrid[j]-1)
        self.vec_datagrid = self.vec_datagrid.T
        i += 6

        data = np.zeros(self.meshgrid[0]*self.meshgrid[1]*self.meshgrid[2])
        data_index = 0
        for line in lines[i:]:
            if "END" in line:
                break
            tmp = line.split()
            data[data_index:data_index+len(tmp)] = tmp
            data_index += len(tmp)

        self.grid_data = np.reshape(data, self.meshgrid, order="F")

    def save(self, filename, data=None):
        """Saves the Shannon entropy in CHG file format"""
        with open(filename, 'w') as file:
            file.write('# generated by KM\n')
            file.write('CRYSTAL\n')
            file.write('PRIMVEC\n')
            file.write(f'    {self.unitcell[0,0]:.7f}  {self.unitcell[0,1]:.7f}  {self.unitcell[0,2]:.7f}\n')
            file.write(f'    {self.unitcell[1,0]:.7f}  {self.unitcell[1,1]:.7f}  {self.unitcell[1,2]:.7f}\n')
            file.write(f'    {self.unitcell[2,0]:.7f}  {self.unitcell[2,1]:.7f}  {self.unitcell[2,2]:.7f}\n')
            file.write('CONVVEC\n')
            file.write(f'    {self.convvec[0,0]:.7f}  {self.convvec[0,1]:.7f}  {self.convvec[0,2]:.7f}\n')
            file.write(f'    {self.convvec[1,0]:.7f}  {self.convvec[1,1]:.7f}  {self.convvec[1,2]:.7f}\n')
            file.write(f'    {self.convvec[2,0]:.7f}  {self.convvec[2,1]:.7f}  {self.convvec[2,2]:.7f}\n')
            file.write('PRIMCOORD\n')
            file.write(f'    {self.atoms_per_unitcell}  1\n')
            for i in np.arange(self.atoms_per_unitcell):
                file.write(f'{self.atom_species[i]}  {self.positions[i][0]:.7f}  {self.positions[i][1]:.7f}  {self.positions[i][2]:.7f}\n')
            file.write('\n\n')

            file.write('BEGIN_BLOCK_DATAGRID_3D\n')
            file.write('3D_field\n')
            file.write('BEGIN_DATAGRID_3D_UNKNOWN\n')
            file.write('  '.join(str(e) for e in self.meshgrid))
            file.write('\n')
            file.write(f'   {self.origin_datagrid[0]:.7f}  {self.origin_datagrid[1]:.7f}  {self.origin_datagrid[2]:.7f}\n')
            for i in np.arange(3):
                for j in np.arange(3):
                    file.write(f'   {self.vec_datagrid[i][j]/self.meshgrid[i]*(self.meshgrid[i]-1):.7f}')
                file.write('\n')

            if data is None:
                data = self.grid_data
            data_f = data.flatten(order="F")

            i = 1
            for num in data_f:
                file.write(f' {num:.8f}')
                if i%6 == 0:
                    file.write('\n')
                    i = 1
                else:
                    i += 1

            file.write('\nEND_DATAGRID_3D\n')
            file.write('END_BLOCK_DATAGRID_3D\n')

    def save_chg(self, filename):
        return self.save(filename, np.absolute(self.grid_data)**2)  # charge density

    def rec_lattice_unitcell(self):
        return np.linalg.inv(self.unitcell) #* 2*np.pi

    def rec_lattice_supercell(self):
        return np.linalg.inv(self.vec_datagrid) #* 2*np.pi

    #@cached_property
    def Vunitcell(self):
        return np.dot(np.cross(self.unitcell[0], self.unitcell[1]), self.unitcell[2])

    #@cached_property
    def Vgrid(self):
        return np.dot(np.cross(self.vec_datagrid[0], self.vec_datagrid[1]), self.vec_datagrid[2])

    #@cached_property
    def Norm(self):
        return np.sum(np.absolute(self.grid_data)**2 *self.dV())

    #@cached_property
    def dV(self):
        # wannier functions are normalized with respect to the supercell (Vgrid)
        # same result as jacobi determinate
        return self.Vgrid()/((self.meshgrid[0])*(self.meshgrid[1])*(self.meshgrid[2]))

    def normalize(self):
        norm = self.Norm()
        self.grid_data = self.grid_data / np.sqrt(norm)


if __name__=="__main__":
    chg = CHGCAR("/home/kmerkel/wo-test_data/test_chgcar/CHGCAR")
    # print(chg.data.shape)
    # print(chg.atoms)
    # print(chg.positions)
    # print(chg.unitcell)
    print(chg.NELECT())
    chg.coarseGrain()
    print(chg.NELECT())
    chg.repeatSupercell(11,11,11)
    print(chg.NELECT())
    # chg.save_xsf("test.xsf")
    print(chg.dV())
    print(chg.vec_datagrid)
    # print(chg.meshgrid)

    # print("reopen...")
    # xsf_chg = wfn_obj("test.xsf")
    # print(xsf_chg.dV())
    # print(xsf_chg.vec_datagrid)
    # print(xsf_chg.meshgrid)

    wf_paths = [
        "/home/kmerkel/Desktop/Si/valence_11x11x11/wannier90_00001.xsf",
        "/home/kmerkel/Desktop/Si/valence_11x11x11/wannier90_00002.xsf",
        "/home/kmerkel/Desktop/Si/valence_11x11x11/wannier90_00003.xsf",
        "/home/kmerkel/Desktop/Si/valence_11x11x11/wannier90_00004.xsf",
        "/home/kmerkel/Desktop/Si/conduction_11x11x11_6WF/wannier90_00001.xsf",
        "/home/kmerkel/Desktop/Si/conduction_11x11x11_6WF/wannier90_00002.xsf",
        "/home/kmerkel/Desktop/Si/conduction_11x11x11_6WF/wannier90_00003.xsf",
        "/home/kmerkel/Desktop/Si/conduction_11x11x11_6WF/wannier90_00004.xsf",
        "/home/kmerkel/Desktop/Si/conduction_11x11x11_6WF/wannier90_00005.xsf",
        "/home/kmerkel/Desktop/Si/conduction_11x11x11_6WF/wannier90_00006.xsf"
    ]

    dV = chg.dV()
    gchg = chg.data/chg.Vunitcell()

    norm = np.sum(gchg * dV)
    print("charges:", norm, norm/(11**3))
    total_density = 0
    print("volume: ", dV*chg.meshgrid[0]*chg.meshgrid[1]*chg.meshgrid[2], chg.Vgrid())


    print("avg charge density1: ", 8/chg.Vunitcell())
    print("avg charge density2: ", norm/chg.Vgrid())

    test_data = np.ones(chg.meshgrid) / np.sqrt(chg.Vgrid())
    norm = np.sum(test_data**2 * dV)
    integral = np.sum(test_data**2 * gchg * dV)

    print("test: avg charge density (expectation value):", integral)
    print("test: norm: ", norm)

    for wf_path in wf_paths:
        print(wf_path)
        wf = wfn_obj(wf_path)
        wf.normalize()
        # print(wf.dV())
        # print(wf.vec_datagrid)


        norm = np.sum(wf.grid_data**2 * dV)
        integral = np.sum(wf.grid_data**2 * gchg * dV)
        print("avg charge density (expectation value):", integral)
        print("norm: ", norm)
        total_density += integral

    # print("total density:", total_density)

    # general physical constants
    HBAR = 65.82119569      # reduced Planck constant in eV*fs
    aB = 0.52917721090380   # bohr radius in angström

    density = 0.265361608
    # density = 8.0 / chg.Vunitcell()


    EPSILON = 11.68
    #alpha = 1.39736
    alpha = 1.563


    print(f"Mean density of valence electrons = {density} Ang^-3")


    # dimensionless electron gas paramter (from yellium model; see Bechstedt 2015)
    rs = (3./(4*np.pi*density*aB**3))**(1./3.)
    print(f"Dimensionless electron gas paramter rs = {rs}")


    # Thomas-Fermi wave vector in 1/angström
    qTF = (12.0/np.pi)**(1./3.) / (np.sqrt(rs) * aB)
    print(f"Thomas-Fermi wave vector qTF = {qTF} Ang^-1")


    # Yukawa screening
    pot_screening = qTF / np.sqrt((1-1./EPSILON)*alpha)
    print(f"Yukawa screening factor pot_screening = {pot_screening} Ang^-1")




# TODO check the endpoint and n/(n-1) factor to make it really compatible with the Wannier functions
# TODO do we have a problem with the argumentation spheres?